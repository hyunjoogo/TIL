# 실행 콘텍스트

- Execution Context
    - 함수가 실행되는 영역, 묶음
    - 함수 코드를 실행하고 실행 결과를 저장
- music(”음악")으로 함수를 호출하면
    - 엔진은 실행 콘텍스트를 생성하고
    - 실행 콘텍스트 안으로 이동
- 실행 콘텍스트 실행 단계
    - 준비 단계, 초기화 단계, 코드 실행 단계
- Execution Context 생성 시점
    - 실행 가능한 코드를 만났을 때
- 실행 가능한 코드 유형
    - 함수 코드, 글로벌 코드, eval 코드
- 코드 유형을 분리한 이유
    - 실행 콘텍스트에서 처리 방법과 실행 환경이 다르기 때문
    - 함수 코드 : 렉시컬 환경
    - 글로벌 코드 : 글로벌 환경
    - eval 코드 : 동적 환경

### 실행 콘텍스트 상태 컴포넌트

- 실행 콘텍스트 상태를 위한 오브젝트
    - 실행 콘텍스트 안에 생성
- 상태 컴포넌트 유형
    - 렉시컬 환경 컴포넌트
    - 변수 환경 컴포넌트
    - this 바인딩 컴포넌트

## 렉시컬 환경 컴포넌트

- 함수와 변수의 식별자 해결을 위한 환경 설정
- 함수 초기화 단계에서 해석한
    - 함수와 변수를 {name : value} 형태로 저장
        - 변수는 { name : undefined}
        - 함수는  { name : function 오브젝트}
    - 이름으로 함수와 변수를 검색할 수 있게 됨
- 함수 밖의 함수와 변수 참조 환경 설정
    - 함수 밖의 함수와 변수를 사용할 수 있게 됨

### 렉시컬 환경 컴포넌트 구성

- 렉시컬 환경 컴포넌트 생성
    - function, with, try-catch에서 생성
- 컴포넌트 구성
    - 환경 레코드
    - 외부 렉시컬 환경 참조

### 렉시컬 환경 컴포넌트 설정

- 환경 레코드에
    - 함수 안의 함수와 변수를 기록
- 외부 렉시컬 환경 참조에
    - function 오브젝트의 [[Scope]]를 설정
- 따라서 함수 안과 밖의 함수와 변수를 사용할 수 있게 됨

### 외부 렉시컬 환경 참조

- 스코프와 실행중인 함수가 Context형태이므로
    - 스코프의 변수와 함수를
    - 별도의 처리 없이 즉시 사용할 수 있음
- 실행 콘텍스트에서
    - 함수 안과 밖의 함수, 변수를 사용할 수 있으므로
    - 함수와 변수를 찾기 위해
    - 실행 콘텍스트를 벗어 나지 않아도 됩니다.
    

## 변수 환경 컴포넌트

- 실행 콘텍스트 초기화 단계에서
    - 렉시컬 환경 컴포넌트와 같게 설정
- 이렇게 하는 이유는?
    - 초기값을 복원할 때 사용하기 위한 것
- 함수 코드가 실행되면
    - 실행 결과를 렉시컬 환경 컴포넌트에 설정
    - 초기값이 변하게 되므로 이를 유지하기 위한 것
    

## 실행 콘텍스트 실행 과정

```jsx
var base= 200;

function getPoint(bonus) {
	var point = 100;
  return point +base+ bonus;
}

console.log(getPoint(70));
```

1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정
2. 마지막 줄에서 getPoint() 함수 호출하면
3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동

—— 준비단계 ——

1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
    - 렉시컬 환경 컴포넌트
    - 변수 환경 컴포넌트
    - this 바인딩 컴포넌트
2. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
    - 함수 안의 함수, 변수를 바인딩 합니다.
    
    ```jsx
    실행 콘텍스트(EC) = {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    
3. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부
    - function 오브젝트의 [[Scope]]를 설정(참조)
    
    ```jsx
    실행 콘텍스트(EC) = {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {},
    		외부 렉시컬 환경 참조(OLER) : {
    			base : 200
    		}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    

—— 초기화단계 ——

1. 호출한 함수의 파라미터 값을
    - 호출된 함수의 파라미터 이름에 매핑
    - 환경 레코드에 작성
2. 함수 선언문을 function 오브젝트로 생성
3. 함수 표현식과 변수에 초기값 설정
4. 여기까지는 외부에 실행 상태를 제공하지 않는다.
    
    ```jsx
    실행 콘텍스트(EC) : {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {
    			bonus : 70,
    		  point: undefined
    		},
    		외부 렉시컬 환경 참조(OLER) : {
    			base : 200
    		}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    

—— 실행 단계 ——

1. 함수 안의 코드를 실행합니다.
    - var point = 100;
2. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있습니다.
    
    ```jsx
    var base= 200;
    
    function getPoint(bonus) {
    var point = 100;
      return point +base+ bonus;
    }
    
    console.log(getPoint(70));
    
    실행 콘텍스트(EC) : {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {
    			bonus : 70,
    		  point: 100
    		},
    		외부 렉시컬 환경 참조(OLER) : {
    			base : 200
    		}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    

예시

```jsx
	function book() {
    function get() {
      return point;
    };
    var point = 123;
    return get();
  }

  console.log(book());
```

1. function 키워드를 만나 book 이라는 function 오브젝트를 생성하고
    
    오브젝트의 [[Scope]]를 글로벌 오브젝트로 설정
    
2. 마지막 줄 book() 함수를 호출하면
3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동

—— 준비단계 ——

1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
    - 렉시컬 환경 컴포넌트
    - 변수 환경 컴포넌트
    - this 바인딩 컴포넌트
2. 환경 레고드를 생성하여 렉시컬 환경 컴포넌트에 첨부
3. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부
    - book 이라는 function 오브젝트의 [[Scope]]를 설정(참조)

—— 초기화 단계 ——

1. 호출한 함수의 파라미터 값을 환경 레코드에 작성하나 없으므로 패스
2. function 키워드를 만나 get이라는 function 오브젝트를 만들고
오브젝트의 [[Scope]]를 bookl 오브젝트로 설정
3. point 라는 변수에 undefined를 설정
4. 여기까지는 외부에 실행 상태를 제공하지 않음
    
    ```jsx
    실행 콘텍스트(EC) : {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {
    			get : function 오브젝트,
    		  point: undefined
    		},
    		외부 렉시컬 환경 참조(OLER) : {
    		}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    

—— 실행 단계 ——

1. book 함수 안의 코드를 실행
2. point 변수에 123을 할당
3. get() 함수를 호출하면 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동

get()함수의 실행 콘텍스트

—— 준비 단계 ——

1. 컴포넌트를 생성하여 실행 콘텍스트에 첨부
    1. 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트
2. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부
3. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부
    - get이라는 function 오브젝트의 [[Scope]]를 설정(참조)
4. 현재까지의 모습
    
    ```jsx
    실행 콘텍스트(EC) : {
    	렉시컬 환경 컴포넌트(LEC) = {
    		환경 레코드(ER) : {
    		},
    		외부 렉시컬 환경 참조(OLER) : {
    			point : 123
    		}
    	}, 
    	변수 환경 컴포넌트(VEC) : {},
    	this 바인딩 컴포넌트(TBC) : {}
    }
    ```
    

—— 초기화 단계 ——

1. 파라미터, function, 변수 없음

—— 실행 단계 ——

1. return point를 만나고, point라는 식별자를 외부 렉시컬 환경 참조에서 찾아 123을 반환
2. get() 함수의 return 값이 book() 함수의 return 값이므로 콘솔창에 123 출력
