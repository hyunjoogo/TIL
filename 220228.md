# 220228

## Arrow Function

- (param) ⇒ { 함수 코드 }
- function() {}의 축약 형태이지만
    - this 참조가 다름
    - prototype과 constructor가 없음
        - 그만큼 가볍다.
        
        ![스크린샷 2022-02-27 오후 11.31.16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1bf0a699-4703-4db5-bd71-ffb2ddd87eb4/스크린샷_2022-02-27_오후_11.31.16.png)
        
    - arguments를 사용할 수 가 없다.
        
        ```jsx
        const book = function () {
        		try {
        			const args = arguments;
        			console.log(args);
        		} catch (e) {
        			console.log(e)
        		}
        	}
        
        	const point = () => {
        		try {
        			const args = arguments;
        			console.log(args);
        		} catch (e) {
        			console.log("사용할 수 없음")
        		}
        	}point(10, 20); //console.log("사용할 수 없음")
        book(10, 20); // { "0": 10, "1": 20 }
        ```
        

## 화살표 함수와 this

- strict 모드에서 함수를 호출할 때
    - 함수 앞에 오브젝트 작성은 필수
    - 화살표 함수는 함수에 this를 갖고 있지 않기 때문에 글로벌 오브젝트를 참조한다.
        - 엔진이 해석할 때, 화살표 함수를 만나면
        - function 오브젝트를 생성하고
        - 화살표 함수가 속한 스코프를 생성한 오브젝트에 바인딩한다.
        - 정적 스코프의 this 사용의 개념이 필요함
        

## 화살표 함수 특징

- function 대신 ⇒ 를 사용, 함수 표현식 형태
    - prototype이 없으므로 함수가 가볍다.
    - constructor가 없으므로 new 연산자로 인스턴스를 생성할 수 없다.
- 화살표 함수에 this가 없다.
    - 화살표 함수로 Function 오브젝트를 생성할 때
    - 정적으로 화살표 함수가 속한 스코프의 this를 화살표 함수에 바인딩한다.
    - 바인딩된 this 참조가 바뀌지 않으면 화살표 함수에서 this로 사용한다.
    - 일반 함수는 call() 등으로  바꿀 수 있다.
- 메소드보다 함수로 사용하는 것이 효율성이 높다.

# 스코프 목적

- 범위를 제한하여
    - 식별자(**Identifier)**를 해결하려는 것
    - 스코프에서 식별자를 해결
- 식별자 해결
    - 변수 이름, 함수 이름을 찾는 것
    - 이 때 스코프를 사용
        - 사람을 시 단위에서 찾는 것보다 구 단위로 찾는게 더 빠르고 동 단위로 찾는게 더 빠른 것처럼
    - 이름을 찾게 되면 값을 구할 수 있음
    - 크게는 이름을 설정하는 것도 식별자 해결
- 스코프는 식별자 해결을 위한 것

### 스코프 설정

- function 오브젝트를 생성할 때 [[Scope]]에 스코프를 설정한다.

```jsx
// 1. 힘수 선언문 해석
	// 생성한 function 오브젝트의 [[Scope]]에 스코프를 설정한다.
	// 2. var 변수 초기화 - 없음
	// 3. 코드 실행
	// book() 함수 내부에서
	// 1 ~ 3번 진행행
	function book() {
		var point = 123;

		function get() {
			console.log(point);
		};

		get();
	}

	book();
```

## 글로벌 오브젝트

- 함수 안에 변수를 선언하면
    - 변수가 함수에 속하게 되지만
- value 변수를 함수 안에 작성하지 않음
    - value 변수가 속하는 오브젝트가 없으며
    - 이때 글로벌 오브젝트에 설정된다.
- 함수도 속하는 오브젝트가 없으면
    - 글로벌 오브젝트에 설정된다.
- 이런 메커니즘을 구현할 수 있는 것은
    - 글로벌 오브젝트가 하나만 있기 때문

### 글로벌 오브젝트 특징

- JS 소스 파일 전체에서
    - 글로벌 오브젝트는 하나만 있음
    - new 연산자로 인스턴스 생성 불가
- JS 소스 파일 전체 기준
    - <script>에 작성된 모든 코드
    - 모든 코드에서 사용 가능

## 글로벌 스코프

- 글로벌 오브젝트가 글로벌 스코프
- 오브젝트는
    - 개발자 관점으로
    - 오브젝트에 함수와 변수를 작성
- 스코프는
    - 식별자 해결을 위한 것으로
    - 엔진 관점
- 글로벌 스코프는 최상위 스코프
    - 함수에서 보면 최종 스코프
- 예시로 알아보는 글로벌 오브젝트의 함수 호출
    
    ```jsx
    var value = 100;
    function book() {
    	return value;
    }
    book();
    ```
    
    - book();
        - book 함수를 호출하려면
        - “오브젝트.book()” 형태로 작성해야 하는데
        - 오브젝트를 작성하지 않고 함수만 작성
    - 오브젝트를 작성하지 않으면
        - 글로벌 오브젝트를 “오브젝트”로 간주하여
        - 글로벌 오브젝트의 book()함수를 호출
    - 즉, 글로벌 스코프에서 book을 찾아 호출

## 바인딩

- 구조적으로 결속된 상태로 만드는 것
    - 대상 : 프로퍼티 이름 ( 변수이름, 함수이름 )
- 바인딩 목적
    - 스코프 설정, 식별자 해결
- 바인딩 시점 구분
    - 정적 바인딩(Lexical, Static Binding)
    - 동적 바인딩(Dynamic Binding)

### 정적, 동적 바인딩

- 정적(렉시컬) 바인딩
    - 초기화 단계에서 바인딩
    - 함수 선언문 이름을 바인딩
    - 표현식(변수, 함수) 이름으로 바인딩
- JS는 대부분 정적 바인딩
- 동적(다이나믹) 바인딩
    - 실행할 때 바인딩
    - eval() 함수, with 문

### 바인딩 시점의 중요성

- 바인딩 시점이 중요한 이유
    - 바인딩할 때 스코프가 결정되기 때문
- function 오브젝트 생성 시점에 스코프 결정
    - 스코프를 function 오브젝트의 [[Scope]]에 설정
    - 스코프가 변경되지 않음
- 함수 안의 모든 함수의 스코프가 같음
    
    ```jsx
    	function book() {
    	// add(), get() 함수의 스코프
    		var value = 100;
    		function add() {
    			value += 200;
    		}
    		function get() {
    			return value;
    		}
    	// add(), get() 함수의 스코프
    }
    ```
    

### 스코프 바인딩 순서
